<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script src="preprocessor.js"></script>
</head>

<body>
    <table  height="100%">
        <tr>
            <th style="text-align: left; vertical-align: top; background-color: antiquewhite; padding-right: 20px;">
                <h2>Dynamic array</h2>

                <input id="type1" type="radio" checked="checked" name="radio" onchange="Generate()">
                <label class="container">Array of basic types</label> <br>
                 
                <input id="type2" type="radio" name="radio" onchange="Generate()">
                <label class="container">Array of copyable structs</label> <br>
                
                <input id="type3" type="radio" name="radio" onchange="Generate()">
                <label class="container">Array of movable structs</label> <br>

                <input id="type4" type="radio" name="radio" onchange="Generate()">
                <label class="container">Array of pointers to structs</label> <br>
                
                <input id="type5" type="radio" name="radio" onchange="Generate()">
                 <label class="container">Array of owner pointers to structs</label>   
                
            </th>
            <th style="text-align: left; vertical-align: top; padding-left: 20px;  overflow: auto;">
                <pre id="output"></pre>
            </th>
        </tr>
    </table>

    <script>
        var list_source =
            `
#include <stdlib.h>
#include <assert.h>
#include <errno.h>
#include <stdio.h>


@(!BASIC)struct book {
@(COPIABLE)    char title[10];
@(POINTER )    char title[10];
@(OWNERPTR)    char* title;
@(MOVABLE )    char* title;
@(!BASIC)};

@(MOVABLE)void book_destroy(struct book* book)
@(MOVABLE){
@(MOVABLE)    free(book->title);
@(MOVABLE)}

@(OWNERPTR)void book_destroy(struct book* book)
@(OWNERPTR){
@(OWNERPTR)    free(book->title);
@(OWNERPTR)}

@(BASIC)struct int_array {
@(!BASIC)struct books {
@(MOVABLE )    struct book* data;
@(COPIABLE)    struct book* data;
@(POINTER )    struct book** data;
@(OWNERPTR)    struct book** data;
@(BASIC   )    int* data;
    int size;
    int capacity;
};

@(BASIC)int int_array_reserve(struct int_array* p, int n)
@(!BASIC)int books_reserve(struct books* p, int n)
{    
    if (n > p->capacity) {

        const size_t new_size_bytes = (size_t)n * sizeof(p->data[0]);
        void* pnew = realloc(p->data, new_size_bytes);
        if (pnew == NULL) return ENOMEM;
            
        p->data = pnew;
        p->capacity = n;        
    }

    return 0;
}

@(BASIC)int int_array_push_back(struct int_array* p, int value)
@(!BASIC)int books_push_back(struct books* p, struct book* book)
{
    if (p->size == INT_MAX) {        
@(MOVABLE )        book_destroy(book);
@(MOVABLE )        book = (struct book){0};
@(OWNERPTR)        book_destroy(book);
@(OWNERPTR)        free(book);
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity) {

        unsigned long long new_capacity = p->capacity + p->capacity / 2;
        
        
        if (new_capacity < p->size + 1) {
            new_capacity = p->size + 1;
        }
        else if (new_capacity > INT_MAX) {            
           new_capacity = INT_MAX;
        }

        int error = int_array_reserve(p, (int)new_capacity);
        if (error != 0) {
@(MOVABLE)        book_destroy(book);
@(!W)        free(book);
            return error;
        }
    }

@(BASIC   )    p->data[p->size] = value;
@(COPIABLE)    p->data[p->size] = *book; /*COPIED*/
@(MOVABLE )    p->data[p->size] = *book; /*MOVED*/
@(MOVABLE )    book->title = NULL; /*MOVED*/
@(POINTER )    p->data[p->size] = book; /*VIEW*/
    p->size++;

    return 0;
}

@(BASIC)void int_array_destroy(struct int_array* p)
@(!BASIC)void books_destroy(struct books* p)
{
@(MOVABLE)    for (int i = 0; i < books->size; i++) {
@(MOVABLE)        book_destroy(&books->data[i]);
@(MOVABLE)    }
@(OWNERPTR)    for (int i = 0; i < books->size; i++) {
@(OWNERPTR)        book_destroy(books->data[i]);
@(OWNERPTR)        free(books->data[i]);
@(OWNERPTR)    }
    free(p->data);
}

int main()
{
@(BASIC)    struct int_array a = { 0 };
@(BASIC)    int_array_push(&a, 1);    
@(BASIC)    int_array_push(&a, 2);
@(BASIC)    int_array_destroy(&a);
@(!BASIC)   struct books books = { 0 };
@(!BASIC)
@(COPIABLE)   struct book book = { .title ="book1" };
@(COPIABLE)   books_push(&books, &book/*COPIED*/);
@(MOVABLE)
@(MOVABLE)    try 
@(MOVABLE)    {
@(MOVABLE)      struct book book = { 0 };
@(MOVABLE)      book.title = strdup("title 1");
@(MOVABLE)      if (book.title == NULL) throw;
@(MOVABLE)      books_push(&books, &book/*MOVED*/);
@(MOVABLE)    }
@(MOVABLE)    catch
@(MOVABLE)    {
@(MOVABLE)    }
@(MOVABLE)
@(MOVABLE)    book_destroy(&book);
@(MOVABLE)    books_destroy(&books);
@(POINTER)
@(POINTER)   struct book book = { .title = "book1" };
@(POINTER)   books_push(&books, &book/*VIEW*/);
@(POINTER)   books_destroy(&books);
@(OWNERPTR)
@(OWNERPTR)  struct book* book = NULL;
@(OWNERPTR)  try 
@(OWNERPTR)  {
@(OWNERPTR)    book = calloc(1, sizeof (struct book));
@(OWNERPTR)    if (book == NULL) throw;
@(OWNERPTR)    book->title = strdup("book1");
@(OWNERPTR)    if (book->title == NULL) throw;
@(OWNERPTR)    books_push(&books, book/*MOVED*/);
@(OWNERPTR)    book = NULL;
@(OWNERPTR)  }
@(OWNERPTR)  catch
@(OWNERPTR)  {
@(OWNERPTR)  }
@(OWNERPTR)
@(OWNERPTR)  book_delete(book);
@(OWNERPTR)  books_destroy(&books);
}
`;

        function Generate() {
            var flags = "";

            
            if (document.getElementById("type1").checked) flags += " BASIC";
            if (document.getElementById("type2").checked) flags += " COPIABLE";
            if (document.getElementById("type3").checked) flags += " MOVABLE ";
            if (document.getElementById("type4").checked) flags += " POINTER";
            if (document.getElementById("type5").checked) flags += " OWNERPTR ";
            
            

            var out = preprocessor(list_source, flags);
            var html = hljs.highlight(out, { language: 'c' }).value;
            document.getElementById("output").innerHTML = html;
        }
        Generate();
    </script>
</body>

</html>